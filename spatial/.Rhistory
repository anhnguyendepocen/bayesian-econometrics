X <- cbind(rep(1,nrow(chidata)), log(chidata$est_fcs_rt), log(chidata$totpop))
# X <- cbind(rep(1,nrow(chidata)), chidata$est_fcs_rt, chidata$bls_unemp)
y <- log(chidata$violent)
N <- nrow(X)
K <- ncol(X)
dat <- list("N" = N, "K" = K, "X" = X, "y" = y, "W" = W)
errorsalm.chi<-errorsarlm(I(log(violent))~I(log(est_fcs_rt))+I(log(totpop)), data=chi.poly@data, W_list)
coef(errorsalm.chi)
W
dim(W)
x
X
X <- cbind(rep(1,nrow(chidata)), log(chidata$est_fcs_rt), log(chidata$bls_unemp))
X
X <- cbind(rep(1,nrow(chidata)), log(chidata$est_fcs_rt), log(chidata$totpop))
X
sar.chi<-lagsarlm(log(chidata$violent) ~ log(chidata$est_fcs_rt) + log(chidata$totpop), data=chi.poly@data, W_list)
summary(sar.chi)
coef(sar.chi)
setwd("~/Desktop/git/bayesian-econometrics/spatial")
library(rstan)
library(spdep)
library(maptools)
library(bayesplot)
chi.poly <- readShapePoly("foreclosures.shp")
chi.poly <- chi.poly[1:50,]                                 # use a smaller data set
chidata <- chi.poly@data                                     # extract data from the spatial polygon
list.queen<-poly2nb(chi.poly, queen=TRUE)                    # if queen = TRUE not specified then rook method used for neighbors
W_list <- nb2listw(list.queen, style="W", zero.policy=TRUE)  # style='W' -> row standardized
W <- listw2mat(W_list)                                       # creates the weight matrix used in stan
plot(readShapePoly("foreclosures.shp"))
plot(W_list, coordinates(chi.poly), points = FALSE, add = TRUE, col = "red")
X <- cbind(rep(1,nrow(chidata)), log(chidata$est_fcs_rt), log(chidata$totpop))
# X <- cbind(rep(1,nrow(chidata)), chidata$est_fcs_rt, chidata$bls_unemp)
y <- log(chidata$violent)
N <- nrow(X)
K <- ncol(X)
dat <- list("N" = N, "K" = K, "X" = X, "y" = y, "W" = W)
start <- proc.time()
fit_sar <- sampling(sar, data = dat, chains = 4, iter = 500, cores = 4)
end <- proc.time()
end["elapsed"] - start["elapsed"]
library(lme4)
?glmer
library(lattice)
xyplot(incidence/size ~ period|herd, cbpp, type=c('g','p','l'),
layout=c(3,5), index.cond = function(x,y)max(y))
?xyplot
?glmer
incidence
cbpp$incidence
gm1 <- glmer(cbind(incidence, size - incidence) ~ period + (1 | herd),
data = cbpp, family = binomial)
gm1
remove(list = ls())
library(rstan)
library(rstanarm)
library(lme4)
library(loo)
# data
n <- 900
X <- data.frame(matrix(c(c(rep(1,n/3),rep(2,n/3),rep(3,n/3)),rnorm(n,0,1)),ncol = 2))
names(X) <- c("group","var1")
y1 <- invlogit(b10+b11*X[which(X$group==1),2])
y2 <- invlogit(b20+b21*X[which(X$group==2),2])
y3 <- invlogit(b30+b31*X[which(X$group==3),2])
y <- c(y1,y2,y3)
round(y)
rbinom(n,1,y)
# inverse logit function
invlogit <- function(x) {
return(exp(x)/(1+exp(x)))
}
# data
n <- 900
X <- data.frame(matrix(c(c(rep(1,n/3),rep(2,n/3),rep(3,n/3)),rnorm(n,0,1)),ncol = 2))
names(X) <- c("group","var1")
y1 <- invlogit(b10+b11*X[which(X$group==1),2])
y2 <- invlogit(b20+b21*X[which(X$group==2),2])
y3 <- invlogit(b30+b31*X[which(X$group==3),2])
y <- c(y1,y2,y3)
round(y)
rbinom(n,1,y)
# coefficients
b10 <- rnorm(1,0,1)
b11 <- rnorm(1,1,1)
b20 <- rnorm(1,0,1)
b21 <- rnorm(1,1,1)
b30 <- rnorm(1,0,1)
b31 <- rnorm(1,1,1)
# for ease of comparison when running models
parameters <- list()
parameters$intercept$b10 <- b10
parameters$intercept$b20 <- b20
parameters$intercept$b30 <- b30
parameters$var1$b11 <- b11
parameters$var1$b21 <- b21
parameters$var1$b31 <- b31
mean(b10,b20,b30)
mean(b11,b21,b31)
# data
n <- 900
X <- data.frame(matrix(c(c(rep(1,n/3),rep(2,n/3),rep(3,n/3)),rnorm(n,0,1)),ncol = 2))
names(X) <- c("group","var1")
y1 <- invlogit(b10+b11*X[which(X$group==1),2])
y2 <- invlogit(b20+b21*X[which(X$group==2),2])
y3 <- invlogit(b30+b31*X[which(X$group==3),2])
y <- c(y1,y2,y3)
round(y)
rbinom(n,1,y)
fakedata <- data.frame(cbind(rbinom(n,1,y),X))
names(fakedata)[1] <- "y"
fakedata$group2 <- c(rep(1,150),rep(2,150),rep(3,150),rep(4,150),rep(5,150),rep(6,150))
fit1 <- glm(y~var1, data = fakedata, family = binomial(link="logit"))
summary(fit1)
coef(fit1)
fit1.1 <- glm(y~var1, data = fakedata, family = binomial(link="logit"), subset = group==1)
coef(fit1.1)
fit1.2 <- glm(y~var1, data = fakedata, family = binomial(link="logit"), subset = group==2)
coef(fit1.2)
fit1.3 <- glm(y~var1, data = fakedata, family = binomial(link="logit"), subset = group==3)
coef(fit1.3)
fit2.1 <- glmer(y ~ var1 + (var1-1|group), data = fakedata, family = binomial(link="logit"))
coef(fit2.1)
fixef(fit2.1)
fit3.1 <- glmer(y~var1+(1|group/group2), data = fakedata, family = binomial(link="logit"))
summary(fit3.1)
coef(fit3.1)
fixef(fit3.1)
ranef(fit3.1)
names(fakedata)
group
fakedata$group
fakedata$group2
fit <- glmer(y ~ var1 + (1 | group) + group2)
fit <- lmer(y ~ var1 + (1 | group) + group2)
fit <- lmer(y ~ var1 + (1 | group) + group2, data = fakedata, family = binomial(link = "logit"))
fit <- glmer(y ~ var1 + (1 | group) + group2, data = fakedata, family = binomial(link = "logit"))
fit
coef(fit)
ranef(fit)
fixef(fit)
formula(fit)
fit <- glmer(y ~ var1 + (1 | group) + (0 + group | group2), data = fakedata, family = binomial(link = "logit"))
coef(fit)
unique(fakedata$group2)
fixef(fit)
ranef(fit)
?glmer
?lmer
?gamm
?gamm4::gamm4()
?gamm4::gamm4
remove(list = ls())
setwd("~/Desktop/git/bayesian-econometrics/spatial")
library(rstan)
library(spdep)
library(maptools)
library(bayesplot)
chi.poly <- readShapePoly("foreclosures.shp")
chi.poly <- chi.poly[1:20,]                                  # use a smaller data set
chidata <- chi.poly@data                                     # extract data from the spatial polygon
list.queen<-poly2nb(chi.poly, queen=TRUE)                    # if queen = TRUE not specified then rook method used for neighbors
W_list <- nb2listw(list.queen, style="W", zero.policy=TRUE)  # style='W' -> row standardized
W <- listw2mat(W_list)                                       # creates the weight matrix used in stan
plot(readShapePoly("foreclosures.shp"))
plot(W_list, coordinates(chi.poly), points = FALSE, add = TRUE, col = "red")
X <- cbind(rep(1,nrow(chidata)), log(chidata$est_fcs_rt), log(chidata$totpop))
# X <- cbind(rep(1,nrow(chidata)), chidata$est_fcs_rt, chidata$bls_unemp)
y <- log(chidata$violent)
N <- nrow(X)
K <- ncol(X)
dat <- list("N" = N, "K" = K, "X" = X, "y" = y, "W" = W)
W
?SpatialGridDataFrame
m = SpatialPixelsDataFrame(points = meuse.grid[c("x", "y")], data = meuse.grid)
data("meuse.grid")
View(meuse.grid)
m = SpatialPixelsDataFrame(points = meuse.grid[c("x", "y")], data = meuse.grid)
summary(m)
m
plot(m)
ptsreg <- spsample(spdf, 1000, type = "regular")
cells = SpatialPixels(ptsreg)
# check results
plot(cells)
points(ptsreg, pch = 16, col = "black")
setwd("~/Desktop/git/bayesian-econometrics/spatial")
library(rstan)
library(spdep)
library(mvtnorm)
library(maptools)
library(bayesplot)
### Simulated Data SAR
W_bin <- rbind(c(0, 1, 1, 0, 0), c(1, 0, 1, 0, 0), c(1, 1, 0, 1, 1), c(0, 0, 1, 0, 1), c(0, 0, 1, 1, 0))
W <- apply(W_bin, 2, function(x){x/rowSums(W_bin)})
I <- diag(5)
lambda <- 0.5
sigma <- 0.3
Sigma <- solve((I - lambda * W) %*% (I - lambda * t(W))) * sigma
X <- cbind(rep(1,5),rnorm(5, 0, 1), rnorm(5, 3, 1))
beta <- c(3, 2.5, -1.5)
mu <- solve(I - lambda * W) %*% X %*% beta
y <- c(rmvnorm(1, mu, Sigma))
dat <- list("N" = nrow(X), "K" = ncol(X), "y" = y, "X" = X, "W" = W)
dat
rep(rbinom(5, 1, 0.5))
rep(rbinom(5, 1, 0.5), 5)
W
diag(0, 10)
fit_sar <- stan(file = "sar.stan", data = dat, chains = 4, iter = 2000, cores = 4)
print(fit_sar, digits = 2)
W_bin <- rbind(c(0, 1, 1, 0, 0), c(1, 0, 1, 0, 0), c(1, 1, 0, 1, 1), c(0, 0, 1, 0, 1), c(0, 0, 1, 1, 0))
W_bin
lower.tri(c(1,2, 3))
lower.tri(c(1,2,3))
lower.tri(c(1,2,3))
?choose
choose(10,2)
choose(10,2)
seq(from=1,to=choose(10,2),by=1)
rep(rbinom(1, 1, 0.4))
rep(rbinom(1, 1, 0.4))
rep(rbinom(choose(10,4), 1, 0.4))
rep(rbinom(choose(10,2), 1, 0.4))
length(rep(rbinom(choose(10,2), 1, 0.4)))
choose(1,2)
choose(1,2)
choose(3,2)
choose(2,2)
choose(3,2)
lower.tri(10)
matrix(rep(0,10*10), nrow = 10)
W_bin <- lower.tri(W_bin)
W_bin
W_bin <- matrix(rep(0,10*10), nrow = 10)
W_bin <- lower.tri(W_bin)
W_bin
N <- 10
W_bin <- matrix(rep(0, N * N), nrow = N)
W_bin[lower.tri(W_bin)] <- rep(choose(N,2), rbinom(1, 1, 0.5))
W_bin
N <- 10
W_bin <- matrix(rep(0, N * N), nrow = N)
W_bin[lower.tri(W_bin)] <- rbinom(1, 1, 0.5)
W_bin
N <- 10
W_bin <- matrix(rep(0, N * N), nrow = N)
W_bin[lower.tri(W_bin)] <- rbinom(1, 1, 0.5, choose(N,2))
W_bin <- matrix(rep(0, N * N), nrow = N)
W_bin[lower.tri(W_bin)] <- rep(rbinom(1, 1, 0.5), choose(N,2))
W_bin
rep(rbinom(1, 1, 0.5), choose(N,2))
W_bin <- matrix(rep(0, N * N), nrow = N)
W_bin[lower.tri(W_bin)] <- rbinom(choose(N,2), 1, 0.5)
W_bin
t(W_bin)
W_bin + t(W_bin)
isSymmetric(W_bin + t(W_bin))
N <- 10
W_bin <- matrix(rep(0, N * N), nrow = N)
W_bin[lower.tri(W_bin)] <- rbinom(choose(N,2), 1, 0.5)
W_bin <- W_bin + t(W_bin)
W <- apply(W_bin, 2, function(x){x/rowSums(W_bin)})
I <- diag(5)
W
rowSum(W)
rowSums(W)
I <- diag(N)
N <- 10
W_bin <- matrix(rep(0, N * N), nrow = N)
W_bin[lower.tri(W_bin)] <- rbinom(choose(N,2), 1, 0.5)
W_bin <- W_bin + t(W_bin)
W <- apply(W_bin, 2, function(x){x/rowSums(W_bin)})
I <- diag(N)
lambda <- 0.5
sigma <- 0.3
Sigma <- solve((I - lambda * W) %*% (I - lambda * t(W))) * sigma
X <- cbind(rep(1,N),rnorm(N, 0, 1), rnorm(N, 3, 1))
beta <- c(3, 2.5, -1.5)
mu <- solve(I - lambda * W) %*% X %*% beta
y <- c(rmvnorm(1, mu, Sigma))
y
W
W_bin
dat <- list("N" = nrow(X), "K" = ncol(X), "y" = y, "X" = X, "W" = W)
fit_sar <- stan(file = "sar.stan", data = dat, chains = 4, iter = 2000, cores = 4)
print(fit_sar, digits = 2)
N <- 100
W_bin <- matrix(rep(0, N * N), nrow = N)
W_bin[lower.tri(W_bin)] <- rbinom(choose(N,2), 1, 0.5)
W_bin <- W_bin + t(W_bin)
W <- apply(W_bin, 2, function(x){x/rowSums(W_bin)})
I <- diag(N)
lambda <- 0.5
sigma <- 0.3
Sigma <- solve((I - lambda * W) %*% (I - lambda * t(W))) * sigma
X <- cbind(rep(1,N),rnorm(N, 0, 1), rnorm(N, 3, 1))
beta <- c(3, 2.5, -1.5)
mu <- solve(I - lambda * W) %*% X %*% beta
y <- c(rmvnorm(1, mu, Sigma))
dat <- list("N" = nrow(X), "K" = ncol(X), "y" = y, "X" = X, "W" = W)
fit_sar <- stan(file = "sar.stan", data = dat, chains = 4, iter = 2000, cores = 4)
N <- 100
W_bin <- matrix(rep(0, N * N), nrow = N)
W_bin[lower.tri(W_bin)] <- rbinom(choose(N,2), 1, 0.5)
W_bin <- W_bin + t(W_bin)
W <- apply(W_bin, 2, function(x){x/rowSums(W_bin)})
W
N <- 20
W_bin <- matrix(rep(0, N * N), nrow = N)
W_bin[lower.tri(W_bin)] <- rbinom(choose(N,2), 1, 0.5)
W_bin <- W_bin + t(W_bin)
W <- apply(W_bin, 2, function(x){x/rowSums(W_bin)})
I <- diag(N)
lambda <- 0.5
sigma <- 0.3
Sigma <- solve((I - lambda * W) %*% (I - lambda * t(W))) * sigma
X <- cbind(rep(1,N),rnorm(N, 0, 1), rnorm(N, 3, 1))
beta <- c(3, 2.5, -1.5)
mu <- solve(I - lambda * W) %*% X %*% beta
y <- c(rmvnorm(1, mu, Sigma))
W
dat <- list("N" = nrow(X), "K" = ncol(X), "y" = y, "X" = X, "W" = W)
fit_sar <- stan(file = "sar.stan", data = dat, chains = 4, iter = 2000, cores = 4)
print(fit_sar, digits = 2)
print(fit_sar, digits = 1)
W
N <- 30
W_bin <- matrix(rep(0, N * N), nrow = N)
W_bin[lower.tri(W_bin)] <- rbinom(choose(N,2), 1, 0.5)
W_bin <- W_bin + t(W_bin)
W <- apply(W_bin, 2, function(x){x/rowSums(W_bin)})
I <- diag(N)
lambda <- 0.5
sigma <- 0.3
Sigma <- solve((I - lambda * W) %*% (I - lambda * t(W))) * sigma
X <- cbind(rep(1,N),rnorm(N, 0, 1), rnorm(N, 3, 1))
beta <- c(3, 2.5, -1.5)
mu <- solve(I - lambda * W) %*% X %*% beta
y <- c(rmvnorm(1, mu, Sigma))
dat <- list("N" = nrow(X), "K" = ncol(X), "y" = y, "X" = X, "W" = W)
start <- proc.time()
fit_sar <- stan(file = "sar.stan", data = dat, chains = 4, iter = 2000, cores = 4)
end <- proc.time()
end["elapsed"] - start["elapsed"]
end["elapsed"] - start["elapsed"]/60
(end["elapsed"] - start["elapsed"])/60
cat("Run time:", (end["elapsed"] - start["elapsed"])/60, "minutes")
cat("Run time:", round((end["elapsed"] - start["elapsed"])/60,2), "minutes")
cat("model run time:", round((end["elapsed"] - start["elapsed"])/60,2), "minutes")
print(fit_sar, digits = 1)
N <- 50
W_bin <- matrix(rep(0, N * N), nrow = N)
W_bin[lower.tri(W_bin)] <- rbinom(choose(N,2), 1, 0.5)
W_bin <- W_bin + t(W_bin)
W <- apply(W_bin, 2, function(x){x/rowSums(W_bin)})
I <- diag(N)
lambda <- 0.5
sigma <- 0.3
Sigma <- solve((I - lambda * W) %*% (I - lambda * t(W))) * sigma
X <- cbind(rep(1,N),rnorm(N, 0, 1), rnorm(N, 3, 1))
beta <- c(3, 2.5, -1.5)
mu <- solve(I - lambda * W) %*% X %*% beta
y <- c(rmvnorm(1, mu, Sigma))
dat <- list("N" = nrow(X), "K" = ncol(X), "y" = y, "X" = X, "W" = W)
start <- proc.time()
fit_sar <- stan(file = "sar.stan", data = dat, chains = 4, iter = 2000, cores = 4)
end <- proc.time()
cat("model run time:", round((end["elapsed"] - start["elapsed"])/60,2), "minutes")
print(fit_sar, digits = 1)
cbind(dat$y, dat$X[,-1])
cbind("y" = dat$y, dat$X[,-1])
cbind("y" = dat$y, c("x1","x2",) = dat$X[,-1])
cbind("y" = dat$y, c("x1","x2") = dat$X[,-1])
cbind("y" = dat$y, "x1" = dat$X[,-1])
cbind("y" = dat$y, "x1" = dat$X[,2])
cbind("y" = dat$y, "x1" = dat$X[,2], "x2" = dat$X[,3])
mat2listw(W)
?mat2listw()
?lagsarlm
check_sar <- lagsarlm(y ~ x1 + x2, data = cbind("y" = dat$y, "x1" = dat$X[,2], "x2" = dat$X[,3]), listw = mat2listw(W))
check_sar <- lagsarlm(y ~ x1 + x2, data = data.frame(cbind("y" = dat$y, "x1" = dat$X[,2], "x2" = dat$X[,3])),
listw = mat2listw(W))
coef(check_sar)
print(fit_sar, digits = 1)
coef(check_sar)
check_sar <- lagsarlm(y ~ x1 + x2, data = data.frame(cbind("y" = dat$y, "x1" = dat$X[,2], "x2" = dat$X[,3])),
listw = mat2listw(W_bin))
coef(check_sar)
check_sar <- lagsarlm(y ~ x1 + x2, data = data.frame(cbind("y" = dat$y, "x1" = dat$X[,2], "x2" = dat$X[,3])),
listw = mat2listw(W))
check_sar <- lagsarlm(y ~ x1 + x2, data = data.frame(cbind("y" = dat$y, "x1" = dat$X[,2], "x2" = dat$X[,3])),
listw = nb2listw(W))
?mat2listw
check_sar <- lagsarlm(y ~ x1 + x2, data = data.frame(cbind("y" = dat$y, "x1" = dat$X[,2], "x2" = dat$X[,3])),
listw = mat2listw(W_bin))
coef(check_sar)
check_sar <- lagsarlm(y ~ x1 + x2, data = data.frame(cbind("y" = dat$y, "x1" = dat$X[,2], "x2" = dat$X[,3])),
listw = mat2listw(W, style = "W"))
coef(check_sar)
check_sar <- lagsarlm(y ~ x1 + x2, data = data.frame(cbind("y" = dat$y, "x1" = dat$X[,2], "x2" = dat$X[,3])),
listw = mat2listw(W_bin, style = "W"))
coef(check_sar)
cat("model run time:", round((end["elapsed"] - start["elapsed"])/60,2), "minutes")
?ode
library(deSolve)
?ode
theta <- 0
init <- c("y1" = 0, "y2" = 0)
harmonic_oscillator <- function(t, y, parms) {
dy1 <- y2
dy2 <- -y1 - theta * y2
list(c(dy1,dy2))
}
time <- seq(0, 100, 0.01)
array(0.15,1)
theta <- 0.15
init <- c("y1" = 1, "y2" = 0)
harmonic_oscillator <- function(t, y, parms) {
dy1 <- y2
dy2 <- -y1 - theta * y2
list(c(dy1,dy2))
}
time <- seq(0, 100, 0.01)
out <- ode(init, times, harmonic_oscillator, parms = NULL)
out <- ode(init, time, harmonic_oscillator, parms = NULL)
harmonic_oscillator <- function(t, y, parms) {
with(as.list(y), {
dy1 <- y2
dy2 <- -y1 - theta * y2
list(c(dy1,dy2))
})
}
out <- ode(init, time, harmonic_oscillator, parms = NULL)
plot(out)
names(out)
out
matplot(x = out[,1], y = out[,2])
out[,1]
matplot(x = out[,2], y = out[,3])
dev.off()
matplot(x = out[,2], y = out[,3])
matplot(x = out[,2], y = out[,3], type = "l")
matplot(x = out[,2], y = out[,3], type = "l", lwd = 2)
time <- seq(0, 1, 0.01)
out <- ode(init, time, harmonic_oscillator, parms = NULL)
matplot(x = out[,2], y = out[,3], type = "l", lwd = 2)
time <- seq(0, 10, 0.01)
out <- ode(init, time, harmonic_oscillator, parms = NULL)
matplot(x = out[,2], y = out[,3], type = "l", lwd = 2)
time <- seq(0, 100, 5)
out <- ode(init, time, harmonic_oscillator, parms = NULL)
matplot(x = out[,2], y = out[,3], type = "l", lwd = 2)
time <- seq(0, 100, 10)
out <- ode(init, time, harmonic_oscillator, parms = NULL)
matplot(x = out[,2], y = out[,3], type = "l", lwd = 2)
time <- seq(0, 100, 5)
out <- ode(init, time, harmonic_oscillator, parms = NULL)
matplot(x = out[,2], y = out[,3], type = "l", lwd = 2)
?call
library(deSolve)
remove(list = ls())
theta <- 0.15
init <- c("y1" = 1, "y2" = 0)
harmonic_oscillator <- function(t, y, parms) {
with(as.list(y), {
dy1 <- y2
dy2 <- -y1 - theta * y2
list(c(dy1,dy2))
})
}
time <- seq(0, 100, 5)
out <- ode(init, time, harmonic_oscillator, parms = NULL)
plot(out)
matplot(x = out[,2], y = out[,3], type = "l", lwd = 2)
dev.off()
plot(out)
time <- seq(0, 100, 0.01)
out <- ode(init, time, harmonic_oscillator, parms = NULL)
plot(out)
time <- seq(0, 100, 5)
out <- ode(init, time, harmonic_oscillator, parms = NULL)
plot(out)
time <- seq(0, 100, 0.01)
out <- ode(init, time, harmonic_oscillator, parms = NULL)
plot(out)
time <- seq(0, 100, 0.001)
out <- ode(init, time, harmonic_oscillator, parms = NULL)
plot(out)
time <- seq(0, 100, 0.01)
out <- ode(init, time, harmonic_oscillator, parms = NULL)
plot(out)
matplot(y1 = out[,2], y2 = out[,3], type = "l", lwd = 2)
dev.off()
matplot(x = out[,2], y = out[,3], type = "l", lwd = 2,
xlab = "y1", ylab = "y2")
matplot(x = out[,2], y = out[,3], type = "l", lwd = 2,
xlab = "y1", ylab = "y2", main = "Harmonic Oscillator")
points(out[1,2], out[1,3], col = "red", pch = 20)
points(out[1,2], out[1,3], col = "firebrickred3", pch = 20)
points(out[1,2], out[1,3], col = "firebrickred", pch = 20)
points(out[1,2], out[1,3], col = "brickred", pch = 20)
points(out[1,2], out[1,3], col = "firered", pch = 20)
points(out[1,2], out[1,3], col = "fire brick red 3", pch = 20)
points(out[1,2], out[1,3], col = "fire brick 3", pch = 20)
points(out[1,2], out[1,3], col = "firebrick", pch = 20)
points(out[1,2], out[1,3], col = "firebrick1", pch = 20)
points(out[1,2], out[1,3], col = "firebrick2", pch = 20)
points(out[nrow(out),2], out[nrow(out),3], col = "cornflowerblue", pch = 20)
legend(0.75,0.5, c("initial condition", "end of sim"), col = c("firebrick2", "cornflowerblue"),
pch = c(20,20))
